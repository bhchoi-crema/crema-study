# Ch16 Sharding Administration

샤딩 관리

## 챕터 목표
- 클러스터 상태 확인하기: 구성원은 어떤 것이 있는가, 어떤 데이터가 저장되는가, 허용되는 연결은 어떤 것인가?
- 클러스터 구성원 추가, 제거, 변경하기
- 데이터 이동 관리하기, 수동으로 데이터 옮기기

## 현재 상태 확인하기
### sh.status로 상태 개요 확인하기
```
sh.status() # parameter verbose : 기본값 false
```
- 출력 정보는 샤딩 버전, 샤드, 데이터베이스, 샤드별 청크 갯수 등
- verbose가 false면
  - 액티브 mongos 인스턴스의 버전과 갯수 출력
  - 청크가 20개 이하면 개별 청크의 정보도 출력해준다.
- verbose에 true를 넣으면 
  - 무조건 개별 청크 정보 출력
  - 액티브 mongos 인스턴스 상세 정보 출력

### 설정 정보 확인하기
클러스터의 모든 설정 정보는 설정config 서버의 `config` 데이터베이스의 컬렉션에 저장된다. 
- 직접 설정 서버에 연결하여 정보를 확인할 수도 있다.
  - 절대 비추. 실수로라도 설정 서버의 데이터를 변경/삭제하는 일이 없도록 하려면, 직접 연결을 피하는 것이 좋다.
  - 대신 mongos에 접속해 config 데이터베이스를 사용하면, 관련 정보를 볼 수 있다. 
  - (설정 서버에 직접 접속하는 대신) mongos를 통해 설정 데이터를 조작하면, mongos가 설정 서버들 간의 동기화를 책임지고, config 데이터베이스를 삭제하는 것과 같은 여러 위험한 동작을 방지한다.    
- 쉘에서 핼퍼를 사용하면 정보를 더 읽기 쉬운 방식으로 볼 수 있다.
- `config` 데이터베이스에 직접 쿼리를 보내서도 클러스터 메타데이터를 확인할 수 있다.
+ `config` 데이터베이스의 컬렉션들
  + `config.shards`: 클러스터의 모든 샤드 기록을 저장한다. `_id` 값은 replica set 이름으로 반드시 유니크해야 함.
  + `config.databases`: 모든(샤디드(partitioned:true), 논샤디드) 데이터베이스 기록을 저장한다.
  + `config.collections`(p278): 모든 샤디드 컬렉션 기록을 저장한다. (샤딩되지 않은 컬렉션은 여기서 확인할 수 없음) 
  + `config.chunks`(p279): 모든 컬렉션의 개별 청크 기록을 저장한다.
  + `config.changelog`: 청크 분할, 이동 기록을 저장하는 컬렉션.
    + 분할 기록(p279): `details`에 원래 청크와 분할 후 청크들의 정보가 기록된다.
    + 이동 기록
      + from 샤드 기록. mongos로부터 from 샤드가 moveChunk 명령를 받으면 기록. details항목에 청크를 옮기는 5단계 과정이 각각 얼마나 걸리는지 밀리초 단위로 기록된다.
        + 1. 명령 파라미터를 확인한다
        + 2. 설정 서버에서 청크 이동을 위해 분산 lock을 획득 가능한지 확인한다.
        + 3. to 샤드와 연결을 시도한다.
        + 4. 데이터를 복사한다. 이 부분은 "critical section"이라 호칭&middot;기록된다.
        + 5. to 샤드, 설정 서버와 통신해 청크 이동을 확정한다.
        + 주의!!: 마지막 단계에서 to 샤드와 from 샤드의 연결상태가 나쁘면, 이동을 되돌리지도 못하고 완료하지도 못하는 상황이 될 수 있다. 이러면, `mongod`가 중지된다.
      + to 샤드 기록. from 샤드로부터 명령을 받으면 다음 과정을 진행한다.
        + 1. 인덱스를 옮긴다: 이동할 컬렉션의 청크가 이전에 가져본 적이 없는 것이라면, 이 샤드는 컬렉션의 어떤 필드가 인덱스인지 알아야 한다.
        + 2. 해당 청크 범위에 존재하는 데이터를 삭제한다. 혹시 실패한 데이터 이동 등으로 데이터가 남아있으면, 현재 데이터에 간섭을 일으킬 수 있기 때문이다.
        + 3. 해당 청크의 모든 다큐먼트를 to 샤드로 복사한다.
        + 4. 복사 과정에서 실행된 이 다큐먼트들 관련 작업을 to 샤드에서 리플레이한다.
        + 5. to 샤드가 새로 옮겨진 데이터를 과반수 서버에 복제할 때까지 기다린다.
        + 6. 청크 메타데이터를 수정해, 청크의 위치를 to 샤드로 확정한다.
        
  + `config.tags`: 샤드 태그를 설정하면 생성되는 컬렉션. 각각의 태그는 특정 청크 범위값을 가진다.
  + `config.settings`: 현재 밸런서 설정과 청크 사이즈를 저장하는 컬렉션. 
    + 이 컬렉션의 다큐먼트를 수정하여, 밸런서를 끄거나 켤 수 있고 청크 사이즈를 변경할 수 있다.
  + 설정 서버에 직접 접속해 컬렉션를 수정하기보다는 mongos를 사용하는 것이 항상 더 나은 방법이다.

## 네트워크 연결상태 확인하기

클러스터 구성원들은 서로 많은 통신을 한다. 이 섹션에서는 샤딩 관련 정보만을 다룬다. 더 자세한 내용은 23장에서.

### 연결상태 관련 통계 확인하기

```
> db.adminCommand({"connPoolStats" : 1})  # 여기 숫자는 별 상관 없음!
```

- `connPoolStats`는 `mongoses`와 `mongods`에 대한 연결 정보를 보여준다. 샤드 구성원인 mongoses와 mongods에서만 이 명령을 실행할 수 있다.
  - hosts항목에서 "host1,host2,host3"와 같은 형태는 설정 서버 연결을 의미한다. "동기화" 연결이라고도 부름.
  - "name/host1,host2,...,hostN"는 샤드에 대한 연결.
  - 다른 샤드에 대한 정보도 볼 수 있다. 하나의 샤드의 primary 서버는 다른 샤드의 primary와 직접 연결되어 데이터를 가져온다.
  - 청크 이동이 발생하면, 샤드는 ReplicaSetMonitor 프로세스를 만들어서, 청크 이동과 관련된(출발지 or 도착지) 샤드의 상태를 추적한다.

### 네트워크 연결 제한하기

하나의 샤드가 하나의 mongos를 통해 관리할 수 있는 최대 연결 수는 다음과 같다:
maxConns = 20,000 − (numMongosProcesses × 3) − (numMembersPerReplicaSet × 3) − (other / numMongosProcesses)

- (numMongosProcesses × 3)
  - mongos는 mongod마다 3개의 연결을 생성한다: 1) 사용자 요청 전달용, 2) 오류 추적용, 3) replica set 상태 모니터링용
- (numMembersPerReplicaSet × 3)
  - primary는 개별 secondary에 1개의 연결을 생성하고, 개별 secondary는 primary에 2개의 연결을 생성한다.  
- (other / numMongosProcesses)
  - other는 mongods에 연결된 기타 프로세스(MMS agent, direct shell 연결(관리용), 청크 이동을 위한 다른 샤드와의 연결)의 갯수
  
- MongoDB 인스턴스가 제대로 종료하면 모든 연결을 자동으로 닫는다. 
- 그러나 정전, 네트워크 문제 등으로 갑자기 연결이 끊기면, 그와 연결된 다른 서버들은 해당 연결에서 어떤 작업을 하기 전까지는 문제가 생긴 것을 모른다.
- 작업을 시도하고 에러를 확인하고 연결을 리프레시하는 과정은 연결 수가 적으면 빠르게 끊나지만, 수천 개의 연결이 리프레시되어야 할 경우 엄청 오래 걸릴 수 있다.
  - 관련 프로세스를 재실행하는 것이 나을 수 있다.

## 서버 관리
### 서버 추가하기

```
sh.addShard("<replica_set>/<hostname><:port>")
```

### 샤드 서버 변경하기

샤드 구성을 바꾸려면, (mongos를 통해서 말고) 직접 샤드의 primary에 접속해서, replica set 재설정을 실행한다. 
그러면 클러스터 설정 과정에서 변경사항을 확인하여, 자동으로 `config.shards`를 업데이트한다.
절대 직접 config.shards를 수정하지 말자!! 유일한 예외상황은 클러스터를 (replica set이 아닌) 독립서버 샤드로 시작했을 경우다. 

- 독립서버 샤드를 replica set 샤드로 변경하기 (p286 참고) 
  - 제일 쉬운 방법은 빈 replica set 샤드를 추가하고, 독립서버 샤드를 제거하는 것이다. 웬만하면 이 방법 추천!

### 샤드 제거하기

```
> db.adminCommand({"removeShard" : "사드 명"})
```
- removeShard는 지우려는 샤드의 모든 청크를 다른 샤드로 옮긴다.
- 청크가 많으면 시간 오래 걸림
- 점보 청크가 있으면 임시로 청크 사이즈를 증가시켜야 이동 작업이 가능할 수도 있다.
- 명령을 다시 실행하면 현재 상태를 확인할 수 있다. 몇 차례든 원하는 만큼 재실행 가능.
- 지우려는 샤드의 데이터베이스를 모두 삭제해야, 샤드를 삭제할 수 있다.
  - movePrimary 명령으로 데이터베이스의 샤딩되지 않은 컬렉션을 저장하는 primary 샤드를 변경할 수 있다.

### 설정 서버 변경하기
- 설정 서버 변경하기 전에는 항상 백업하자!
- 설정 서버를 변경하려면 모든 mongos 프로세스를 중단시켜야 한다. 모든 mongos는 같은 --configdb 값을 가져야 함.

## 데이터 밸런싱
보통 MongoDB는 데이터 밸런싱을 자동으로 처리한다. 이 섹션에서는 자동 밸런싱을 켜고 끄는 법과 밸런싱 과정에 개입하는 법을 배운다.

### 밸런서
관리 작업을 할 때는 거의 대부분 먼저 밸런서를 꺼줘야 한다. 다음 핼퍼를 통해 쉽게 밸런서를 끌 수 있다.
```
> sh.setBalancerState(false)

```
밸런서를 끈다고 해서, 이미 진행 중인 밸런싱 작업이 바로 중단되는 것은 아니다. 청크 이동은 쉽게 중단시킬 수 없다. 밸런싱 작업이 진행 중인지 확인하려면 다음의 명령을 실행하면 된다.
```
> db.locks.find({"_id" : "balancer"})["state"]
```
밸런서는 시스템에 부하를 준다. 청크를 옮길 때, 도착 샤드는 출발 샤드에 청크가 포함하는 모든 다큐먼트에 대한 쿼리를 보내고, 해당 다큐먼트를 추가한다. 그후 출발 샤드는 해당 다큐먼트를 삭제해야 한다. 다음 두 가지 상황에서 청크 이동은 성능 저하를 일으킬 수 있다.

1. 핫스팟 샤드 키는 지속적인 청크 이동을 야기한다. 시스템은 핫스팟 샤드의 데이터 흐름을 처리할 수 있는 성능을 갖추고 있어야 한다. 
2. 새로운 샤드가 추가되면 밸런서가 샤드를 채우려고 지속적인 청크 이동을 시도할 것이다.

청크 이동이 서비스에 지나친 부하를 준다면, config.settings 컬렉션을 수정해 밸런싱 작업을 스케줄링할 수 있다. 다음 update 명령을 실행하면, 밸런싱이 새벽 1시에서 4시 사이에만 허용된다.
```
db.settings.update({"_id" : "balancer"},{"$set" : {"activeWindow" : {"start" : "13:00", "stop" : "16:00"}}}, true )
```

주의! 
- 밸런싱 작업을 수동과 자동 모두로 할 계획이라면, 밸런서가 (히스토리가 아니라) 오직 현재 상태만을 고려한다는 것을 잊지 말자. 
- 밸런서는 오직 청크 숫자만을 고려한다. 데이터 크기는 상관 안 함! 잘못하면 작은 크기의 다수 청크를 가진 샤드에서 덩치 큰 소수 청크를 가진 샤드로 청크 이동이 일어날 수 있다.  

### 청크 크기 변경하기
mongos에 접속해 다음과 같은 명령을 실행해 청크 크기를 변경할 수 있다.
```
db.settings.save({"_id" : "chunksize", "value" : 크기(MB)})
```

- 청크 크기가 너무 작으면 이동이 불필요하게 너무 자주 일어날 수 있다.
- 청크 크기가 너무 크면 한번 이동할 때 속도가 너무 느릴 수 있다.
- 청크 크기를 변경해도 현존하는 청크의 크기가 바로 변경되지는 않는다. 청크 분할이 일어나면서 점진적으로 설정한 크기로 향해 간다.
- 이 설정은 클러스터 전체(모든 데이터베이스와 컬렉션)에 영향을 준다. 컬렉션 별로 다른 청크 사이즈가 필요하다면, 컬렉션을 서로 다른 클러스터에 넣거나 절충한 크기를 설정해야 한다.

### 청크 옮기기 
청크 옮기기 명령
```
> sh.moveChunk("컬렉션", {범위}, "도착 샤드") - 예:sh.moveChunk("test.users", {"user_id" : NumberLong("1844674407370955160")}, "spock")
```

청크가 너무 크면 옮길 때 에러가 발생한다. 이때는 수동으로 청크를 분할 해줘야 함. (또는 전체 청크 크기를 올려줄 수도 있다.)

청크 분할 명령
```
> sh.splitAt("test.ips", {"user_id" : NumberLong("2000000000000000000")})
```

### 점보 청크

점보 청크 처리
1. 밸런서 종료
2. 임시로 청크 크기를 늘린다
3. 점보 청크를 다른 샤드로 옮긴다. (필요하면 secondaryThrottle옵션 사용)
4. 댜른 샤드들과 비슷한 개수의 청크를 가질 때까지 남은 청크를 splitChunk한다.
5. 청크 크기를 원래 값으로 설정하고 배런서를 켠다.

점보 청크 방지하기
- 샤드 키를 더 세밀하게 수정해야 한다. 예: 년/월/일 샤드 키는 시,분,초를 추가하는 등으로 수정 가능.


### 설정 리프레싱
가끔 mongos가 설정을 설정 서버에서 제대로 못 가져오는 경우가 있다. 그럴 때는 다음 명령을 수동으로 실행해서 모든 캐시를 삭제하자:
```
> db.adminCommand({"flushRouterConfig" : 1})
```
이 명령이 안 먹히면, 캐시를 삭제하기 위해 모든 mongos와 mongod 프로세스를 재실행해야 한다.

