# Ch15 Choosing a Shard Key

샤딩에서 가장 중요하고 어려운 작업: 

샤드 키 선택하기 == 데이터를 어떤 식으로 분산시킬 것인가?

## 챕터 목표
1. 여러 후보들 중 샤드 키를 고를 때 어떤 기준으로 선택해야 하는가?
2. 샤드 키 사용 사례 살펴보기
3. 샤드 키로 사용할 수 없는 것은 무엇인가?
4. 데이터 분산 방식을 커스터마이즈할 때 사용할 수 있는 다른 대체 전략은 무엇인가?
5. 수동 데이터 샤딩은 어떻게 하는가?

## 1. 여러 후보들 중 샤드 키를 고를 때 어떤 기준으로 선택해야 하는가?
### 샤딩 전에 검토할 점들
- 몇 개의 샤드를 사용할 예정인가? 
  - 모든 샤드에 접근하는 쿼리를 많이 사용해야 한다면, 샤딩은 의미 없다. 클러스터가 커지더라도 거의 모든 쿼리는 항상 샤드 키를 가지고 특정한 샤드에만 접근하는 방식이어야 한다.
- 읽기&middot;쓰기 대기시간 감소를 위해 샤딩을 하는 것인가? 
  - 대기시간을 감소시키려면, 지리적으로 가깝거나 성능 좋은 머신으로 요청을 보낼 수 있어야 한다.
- 읽기&middot;쓰기 처리량을 증가를 위해 샤딩을 하는 것인가? 
  - 처리량을 증가시키려면, 병렬 처리 부분을 늘리고 요청을 클러스터 전체에 균등하게 보낼 수 있어야 한다.
- 일정 데이터 크기당 시스템 리소스량 증가를 위해 샤딩을 하는 것인가? 
  - 그러려면, 데이터셋을 가능한 작게 유지해야 한다.

위 질문들은 샤드 키의 평가기준이다. 이를 통해 자신의 상황에 맞는 샤드 키가 무엇인가 판단해 보자.

## 2. 샤드 키 사용 사례 살펴보기
### 샤드 키 종류

샤드 키 종류는 크게 다음 세 종류로 나눌 수 있다.

- 증가하는 샤드 키
  - 모든 청크가 하나의 샤드에서만 생성되기 때문에 청크를 고르게 분배하기 어려움. 좀 더 고르게 분산된 시스템에서는 상대적으로 쉽게 해결할 수 있는문제도, 여기서는 MongoDB가 청크를 계속해서 다른 샤드로 옮겨야만 해결할 수 있다. 그대로는 샤드 키로 안 쓰는 것이 좋다!

- 랜덤 분산 샤드 키
  - 특정한 패턴이 없는 키들. 모든 샤드의 크기가 거의 같은 비율로 증가하여, 청크를 옮길 필요성이 줄어든다. 유일한 단점은 MongoDB가 RAM 크기 이상의 데이터에 랜덤하게 접근할 때 효율적이지 못하다는 것이다. 충분한 RAM을 활용할 수 있거나 (상대적으로) 속도가 중요하지 않다면, 랜덤 키를 통해 작업량을 클러스터 전체에 고르게 분산할 수 있다.

- 위치 기반 샤드 키
  - 유저 IP, 위도, 경도 같은 키들. 여기서 "위치"는 꼭 물리적 위치와 관련 있는 것만은 아니라, 크리마의 brand와 같이 데이터를 한데 묶을 수 있는 기준이라고 할 수 있다. 위치 기반 샤드 키는 데이터와 데이터의 실제 사용자 간 거리를 가깝게 유지하고, 관련 데이터를 같은 저장공간에 저장하도록 하는데 유용하다.
  - 예제(p264)처럼 규칙을 정하면, 밸런서가 청크들을 옮길 때, 청크를 정해진 범위에 따라 정해진 샤드로 옮기려 한다. 이 과정은 규칙을 정한다고 바로 실행되는 것이 아니다. 밸런서는 샤드에 균등하게 청크를 분산하려 할 것이고, 규칙에 정해지지 않은 청크는 이에 따라 옮겨진다. 
  
### 샤드 키 전략
- 해시드 샤드 키
  - 데이터 로딩을 최대한 빠르게 할 때 좋다.
  - 해시드 샤드 키는 어떤 필드라도 랜덤하게 분산되도록 만들 수 있다. 따라서 증가하는 샤드 키를 사용하는 많은 쿼리를 처리하면서, 쓰기 위치가 랜덤하게 분산되도록 하고 싶을 때 좋다.
  - 대신 범위 쿼리를 특정해서 사용할 수 없다는 단점이 있다. 즉 범위 쿼리를 사용할 일이 없을 때도 해시드 샤드 키는 좋은 선택지가 된다.
  - 해시드 샤드 키를 사용하면 unique 옵션(고유하지 않으면 insert 불가)을 쓸 수 없다.
```
sh.shardCollection("컬렉션", {샤드 키}) - 예: sh.shardCollection("app.users", {"username" : "hashed"})

# 샤드 키 형식은 {"필드명" : 1 또는 "hashed"}
# `shardCollection`는 자동으로 빈 청크를 생성하여 클러스터에 균등하게 분산시킨다.
```
- GridFS에서 해시드 샤드 키 사용하기
  - GridFS에서는 파일을 청크 단위로 나눠서 저장하고, 샤딩에서는 컬렉션을 청크에 나눠 저장한다. "GridFS 청크"와 "샤딩 청크"를 구별해야 한다.
  - GridFS 컬렉션은 샤딩하기 좋은 사례지만, `fs.chunks`에서 자동으로 생성하는 인덱스들은 샤드 키로 쓰기에 좋지 않다:
    - `{"_id" : 1}`는 증가하는 키.
    - `{"files_id" : 1, "n" : 1}`도 `fs.files`의 `_id` 필드 값을 가져오므로 역시 증가하는 키.
  - `files_id` 필드의 해시드 인덱스를 생성해서 사용하면, 각각의 파일을 랜덤하게 클러스터에 분산시킬 수 있다. 이 방식의 장점은 두 가지다: 모든 샤드에 고르게 쓸 수 있고, 하나의 파일을 읽을 때 오직 하나의 샤드만 접근하면 된다.
    - `fs.files` 컬렉션은 `fs.chunks`보다 훨씬 작기 때문에 굳이 샤딩할 필요는 없다. 해도 그만 안 해도 그만!
  
  
- 파이어호스 전략
  - 특정 서버가 다른 서버보다 훨씬 성능이 좋다면, 해당 서버가 더 많은 작업을 처리하길 원할 것이다.
  - 예: SSD 샤드가 하나 있고 HDD 샤드가 10개 있을 때, 모든 insert를 SSD로 가게 하고 밸런서가 오래된 청크를 다른 샤드로 옮기게 한다. 이러면, HDD에서 쓰기를 허용할 때보다 훨씬 쓰기 대기 시간이 감소할 것이다.
  - 단점은 확장하기 어렵다는 것이다. SSD 샤드가 처리할 수 없을 만큼 많은 쓰기 작업이 들어온다면, 쉽게 작업을 분산할 방법이 없다.
  - 파이어호스 전략을 사용하는 방법은 다음과 같다:
1. 쓰기 작업을 받을 샤드에 태그를 추가한다.
```
sh.addShardTag("shard-name", "ssd")
```
2. 해당 샤드의 태그 범위를 증가하는 키의 현재 값에서부터 무한 값까지로 설정하여, 모든 새로운 쓰기 작업을 받도록 한다: 
```
sh.addTagRange("dbName.collName", {"_id" : ObjectId()}, {"_id" : MaxKey}, "ssd")
```
3. 크론 작업을 설정하여 일정 주기(예: 하루 1회)로 태그 범위를 수정하도록 설정한다. 밸런서가 태그 범위 밖으로 밀려난 예전 청크들을 다른 샤드로 옮길 것이다:
  
```
> use config
> var tag = db.tags.findOne({"ns" : "dbName.collName", "max" : {"shardKey" : MaxKey}})
> tag.min.shardKey = ObjectId()
> db.tags.save(tag)
```
**주의!! - 모든 쓰기 작업을 처리할만한 성능 좋은 서버가 없거나 태그를 사용하지 않으면, 증가하는 키를 샤드 키로 사용하지 말아야 한다.**


- 멀티 핫스팟
  - 샤딩에서는 쓰기가 클러스터에 고르게 분포해야 효율적이지만, 독립 mongod 서버는 오름차로 쓰기 작업을 처리할 때 가장 효율적이다.
  - 이 전략은 핫스팟(쓰기가 몰리는 지점)을 여럿 만들어서, 쓰기 작업이 클러스터 전체로는 균등하게 분산되지만, 하나의 샤드 안에서는 오름차로 처리하는 방식이다.
  - 이 전략을 사용하려면, 복합 샤드 키를 사용해야 한다: 
    - 1번째 값은 낮은 카디널리티를 가진 랜덤 값
    - 2번째 값은 증가하는 키
  - 충분한 데이터를 입력하면, 결국에는 1번째 랜덤 값 하나당 대략 하나의 청크를 갖게 될 것이다. 1번째 랜덤 값 하나가 하나의 "핫스팟"이 되는 것이다.
  - 하나의 샤드에 하나의 청크만 있다면, 모든 샤드에서 오름차로 쓰기 작업을 처리하므로 효율적일 것이다. 단, 새로운 샤드를 추가해도 쓰기 작업을 받을 "핫스팟" 청크가 없어서, 확장할 수가 없다.
  - 따라서, 하나의 샤드에 2~3개의 핫스팟 청크(확장성을 위해) 갖는 것이 가장 좋다.
    - 단 핫스팟 청크가 너무 많으면, 오름차 쓰기 작업의 효율성을 살리지 못하고 사실상 랜덤 쓰기와 마찬가지가 되어 버린다.


## 3. 샤드 키로 사용할 수 없는 것은 무엇인가?
### 샤드 키 규칙과 가이드라인
샤드 키 선택 방법은 인덱스 선택과 비슷하다. 사실 대개 가장 자주 사용하는 인덱스를 샤드 키로 사용한다.

### 샤드 키 제한
- 배열은 샤드 키가 될 수 없다.
- 입력한 샤드 키 값은 변경될 수 없다. 특정 다큐먼트의 샤드 키를 변경하려면, 해당 다큐먼트를 삭제하고, 키 값을 변경하여 새로 입력하는 수밖에 없다.
- Geospatial, Multikey, Text 인덱스는 샤드 키로 사용할 수 없다.

### 샤드 키 카디널리티
- 인덱스처럼 샤드 키의 카디널리티는 높을 수록, 샤딩의 성능이 더 좋다. 굳이 카디널리티가 낮은 필드를 샤드 키로 써야 한다면, 다른 필드와 조합해서 쓸 수 있다. 이 경우, 조합 키의 카디널리티가 높아야 한다.  

## 4. 데이터 분산 방식을 커스터마이즈할 때 사용할 수 있는 다른 대체 전략은 무엇인가?

샤드 키를 고르고 MongoDB가 자동으로 데이터 분산하게 하는 것만으로는 요구사항을 처리할 수 없을 때가 있다. 그런 경우 시도해볼 수 있는 것들이 있다. 단, 클러스터 크기가 크고 처리량이 많을 수록, 이런 수단보다는 MongoDB가 자동으로 데이터 분산하도록 맡기는 것이 효과적이다.

### 다중 데이터베이스와 다중 컬렉션을 포함하는 클러스터 구성하기
데이터의 질이 균등하면, 클러스터의 모든 샤드에 컬렉션을 고르게 분산하는 방식이 효율적이다. 그러나 특정 데이터가 다른 데이터보다 "덜 중요하다면", 덜 중요한 데이터가 더 비싼 서버의 저장 공간을 차지하는 것을 원치 않을 수 있다. 또는 하나의 성능 좋은 샤드가 있고, 이 샤드에는 오직 실시간 컬렉션만 저장되길 원할 수도 있다. 이런 경우, 아예 별개의 클러스터를 구축할 수도 있지만, 특정 데이터를 특정한 위치에 저장하도록 MongoDB에서 설정할 수도 있다.

- 샤드에 태그 추가하기
```
sh.addShardTag("샤드 명", "태그") - 예: sh.addShardTag("shard0001", "high")
```
- 특정 컬렉션을 특정 샤드에 저장하도록 설정하기
```
sh.addTagRange("컬렉션", {최소조건 다큐먼트(필드:밸류 형식)}, {최대조건 다큐먼트(필드:밸류 형식)}, "목표 샤드 태그") - 예: sh.addTagRange("super.important", {"shardKey" : MinKey}, {"shardKey" : MaxKey}, "high")
```
- 샤드에 태그 삭제하기
```
sh.removeShardTag("샤드 명", "태그") - 예: sh.removeShardTag("shard0005", "whatever")
```

- `addTagRange`로 추가한 태그 범위를 삭제하는 핼퍼는 없고 수동으로 삭제해야 한다. `mongos`의 `config.tags`에 접근해 수동으로 처리할 수 있다. 마찬가지로 `config.shards`의 `tag`필드를 조작해서 샤드 태그를 수정할 수 있다.


## 5. 수동 데이터 샤딩은 어떻게 하는가?

특정 상황에서는 데이터 분산 방식을 완전히 통제하는 것이 필요할 수도 있다. 이런 경우 밸런서를 꺼서 자동으로 데이터가 분산되지 않도록 하고, `moveChunk` 명령을 사용해 수동으로 데이터를 분산시킬 수 있다.

1. 밸런서를 끄려면, 아무 `mongos`에 접속해 아래 명령을 사용해 `config.settings`의 값을 갱신하면 된다. 데이터 분산 작업 중일 때는 이 명령이 바로 적용되지 않고, 작업이 끝난 후 적용된다:
```
db.settings.update({"_id" : "balancer"}, {"enabled" : false}, true)
```

2. 밸런서가 꺼지면, 수동으로 데이터를 옮길 수 있다. 그러기 위해서는 다음 명령으로 `config.chunks`를 확인해 데이터 청크의 위치를 알아야 한다:
```
db.chunks.find()
```
3. 이제 moveChunk 명령으로 청크를 다른 샤드로 옮길 수 있다:
```
sh.moveChunk("청크를 포함하는 컬렉션", {청크를 특정할 수 있는 쿼리}, "목적지 샤드")
- 예: sh.moveChunk("test.manual.stuff", {user_id: NumberLong("-1844674407370955160")}, "test-rs1")
```
